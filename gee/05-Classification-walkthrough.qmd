# Classification Walkthrough {#sec-gee-classification-walkthrough}

*Schritt-für-Schritt Anleitung zur Landnutzungsklassifikation*

Diese Anleitung ist speziell für eine eigenständige Demonstration vorbereitet.

## Sentinel-2 Daten laden

- Sucht nach Sentinel-2 MSI: MultiSpectral Instrument, Level-2A

```js
var sentinel = ee.ImageCollection("COPERNICUS/S2_SR");

// try printing, will abort (>5000 elements)
print(sentinel);
```

## Daten filtern und visualisieren

```js
var s2_filtered = s2.filterDate("2020-05-01", "2020-06-30")
```

Versucht, die Daten zur Karte hinzuzufügen:

```js
Map.addLayer(filtered);
```

Sieht nicht gut aus. Überprüft die Dokumentation erneut, verwendet band information für ein RGB-Bild:

```js
Map.addLayer(s2_filtered, {"bands":["B4","B3","B2"]});
```

Immer noch nicht gut. Verwendet das Karten-UI, um die layer settings zu verwenden. Streckt das Bild auf 98% und erhöht das gamma auf etwa 4. Diese Einstellungen können nun über den import button in das Script importiert werden.

## Area of Interest definieren

Schaut euch all die Wolken an! Wir wollen Bilder mit geringer Wolkenbedeckung in unserem Untersuchungsgebiet. Zeichnet ein Untersuchungsgebiet mit dem "draw square" tool und importiert es als Polygon namens AOI:


var aoi = ee.Geometry.Polygon(
        [[[7.986557722409096, 47.565286694437866],
          [7.986557722409096, 46.845042087063305],
          [9.398300886471596, 46.845042087063305],
          [9.398300886471596, 47.565286694437866]]], null, false)



## Weitere Filterung

Verwendet dieses Polygon, um die S2-Daten weiter zu filtern. Gebt die Zwischenergebnisse des folgenden Statements aus:

var s2_filtered = s2.filterDate("2020-05-01", "2020-06-30")
  .filterBounds(aoi) 
  .filter(ee.Filter.lt("CLOUDY_PIXEL_PERCENTAGE",20))
  .median()                         
  
  
## Trainingsdaten erstellen

```js
// Erstellt einen Datensatz von Punkten mit derselben Landbedeckungsklasse mit dem "point" tool
// Wiederholt dies für andere Landbedeckungsklassen. Ändert das import statement zu "FeatureCollection" und
// fusioniert die Datensätze mit der folgenden Methode:

var training = urban.merge(rural).merge(forest).merge(water);
```

Gebt die Daten aus und zeigt, dass kein feature label an "training" weitergegeben wird. Fügt diese Information hinzu, indem ihr eine Spalte "landcover" mit einem numerischen Wert hinzufügt, der die 4 Landbedeckungsklassen unterscheidet.

## Werte aus den Bändern extrahieren

Extrahiert die Werte aus den verschiedenen Bändern mit "sampleRegions":

var sampled = s2_filtered.select(["B4", "B3", "B2"]).sampleRegions({
  collection: training,
  properties: ["landcover"],
  scale: 30
})

## Classifier erstellen

Erstellt einen Classifier mit einer dieser Funktionen. Was ist eine "gute" Anzahl von Bäumen für Random Forest?

var classifier = ee.Classifier.smileCart().train({features: sampled, classProperty: "landcover"})
var classifier = ee.Classifier.smileNaiveBayes().train({features: sampled, classProperty: "landcover"})
var classifier = ee.Classifier.smileRandomForest(10).train({features: sampled, classProperty: "landcover"})


## Klassifikation durchführen

Klassifiziert den gefilterten S2-Datensatz mit dem Classifier. Da wir unsere Bänder erneut spezifizieren müssen, erstellt eine Variable dafür:

```js
var bands = ["B4", "B3", "B2"]
var classified = s2_filtered.select(bands).classify(classifier)
```

## Ergebnis visualisieren

Fügt den klassifizierten Datensatz zur Karte hinzu. "Mappt" die verschiedenen Landbedeckungsklassen zu verschiedenen Farben, z.B.:

```js
Map.addLayer(classified,{min: 1, max: 4, palette: ["darkgreen", "lightgreen", "gray", "blue"]})
```


